// reduce()
// aka: fold, accumulate

// iterate over a list
// applying a function to an accumulated value and the next item in the list
// until iteration is complete, and the accumulated value is returned

// takes a reducer function, and an initial value
// returns the accumulated value

Array.prototype.reduce(); // initial list provided by 'this'

// array.reduce(
//     reducer: (accumulator: any, current: Any) => Any, current: Any) => Any,
//     initialValue: Any
// ) => accumulator: Any

// the reducer's job is to "fold" the current value into the accumulated value

// the reducer returns the new accumulated value, and reduce() moves on to the next
// value in the array

// an initial value may be needed, but in this case it's zero

[2, 4, 6].reduce((acc, n) => acc + n, 0); // 12

// first time the reducer is called, acc starts at 0
// reducer returns 0 + 2
// next call, acc = 2, n = 4
// reducer returns 2 + 4
// last call, acc = 6, n = 6
// reducer returns 12
// since iteration is finished, reduce() returns 12

// abstracting a summing reducer
const summingReducer = (acc, n) => acc + n;

[2, 4, 6].reduce(summingReducer, 0);

// Reduce is Versatile -------------------------------------------------

// It is easy to define map(), filter(), forEach() and lots of other things using reduce()

// Map

const map = (fn, arr) =>
  arr.reduce((acc, item, index, arr) => {
    return acc.concat(fn(item, index, arr));
  }, []);

// the accumulated value is a new array with a new element for each value in the original
// new values are generated by applying mapping function (fn) to each element in the arr
// and calling fn with the current element, and concatenating the result to acc array

// Filter

const filter = (fn, arr) =>
  arr.reduce((newArr, item) => {
    return fn(item) ? newArr.concat([item]) : newArr;
  }, []);

//   For each of the above examples, you have a list of data, iterate over that data applying
//   some function and folding the results into an accumulated value.

// Compose

// abstract a function that would represent:  f(g(h(x)))

// to make this happen, reduce needs to run in reverse

// this can be done with reduce(), but js has reduceRight() available

const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);

// Pipe

const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);

const add1ThenDouble = pipe(
  add1,
  double
);
add1ThenDouble(2); // 6
// ((2 + 1 = 3) * 2 = 6)

// Redux uses reducer functions to manage application state. A Redux-style reducer takes
// the current state and an action object and returns the new state:

// reducer(state: Any, action: { type: String, payload: Any}) => newState: Any

// Reducer rules:

// 1. A reducer called with no parameters should return its valid initial state.
// 2. If the reducer isnâ€™t going to handle the action type, it still needs to return the state.
// 3. Redux reducers must be pure functions.

// rewrite the summing reducer as a Redux-style reducer that reduces over action objects

const ADD_VALUE = "ADD_VALUE";
const summingReducer = (state = 0, action = {}) => {
  const { type, payload } = action;
  switch (type) {
    case ADD_VALUE:
      return state + payload.value;
    default:
      return state;
  }
};

// The cool thing about Redux is that the reducers are just standard reducers that you can
// plug into any reduce() implementation which respects the reducer function signature,
// including [].reduce(). That means you can create an array of action objects and reduce
// over them to get a snapshot of state representing the same state you'd have if those
// same actions were dispatched to your store

const actions = [
  { type: "ADD_VALUE", payload: { value: 1 } },
  { type: "ADD_VALUE", payload: { value: 1 } },
  { type: "ADD_VALUE", payload: { value: 1 } }
];
actions.reduce(summingReducer, 0); // 3
